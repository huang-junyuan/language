## 整数溢出机制

### 无符号整数溢出

对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。

### 有符号整数溢出

对于signed整型的溢出，C的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的。

有符号整型溢出又可分为向上溢出和向下溢出。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出>2^(8k-1) – 1我们称之为向上溢出, 向下超出<-2^(8k-1), 我们称之为向下溢出.

对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。

```cpp
signed char x;
x = 125 + 5;
```

上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。

```cpp
signed char x;
x = (-100) + (-100);
```

上面代码会输出56，因为200的二进制为11001000，-200根据补码的算法，得出00111000即56。

上面的两个例子无论是向上溢出还是向下溢出，绝对值都在相对于无符号整型能表示的范围内。对于signed char如果结果为400，超出了位数表示范围，取结果的低八位。

```cpp
signed char x;
x = 200 + 200;
```

因此上面代码会输出-112。如果x的结果为负数且超出了255，则取结果的低八位，并进行补码的反向操作，减一后取反。



## 数据类型转换

当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为**无符号类型**

分别定义一个signed int型数据和unsigned int型数据，然后进行大小比较

```cpp
 unsigned int a=20;
 signed int b=-130;
```

实验证明b>a，也就是说－130>20，这是因为在C语言操作中，如果遇到无符号数与有符号数之间的操作，编译器会自动转化为无符号数来进行处理，因此a＝20，b＝4294967166，这样比较下去当然b>a了。



再举一个例子：

```cpp
 unsigned int a=20;
 signed int b=-130;
 std::cout<<a+b<<std::endl;
```

结果输出为4294967186，同样的道理，在运算之前，a＝20，b被转化为4294967166，所以a＋b＝4294967186

减法和乘法的运算结果类似。



如果作为signed int型数据的b=-130，b与立即数之间操作时不影响b的类型，运算结果仍然为signed int型：

```cpp
signed int b=-130;
std::cout<<b+30<<std::endl;
```

输出为-100。



而对于浮点数来说，浮点数（float，double）实际上都是有符号数，unsigned 和signed前缀不能加在float和double之上，当然就不存在有符号数跟无符号数之间转化的问题了。



## 字符读入

使用cin读入字符会忽略空白符