## 静态变量

在 C 语言中，static 关键字不仅可以用来修饰变量，还可以用来修饰函数。在使用 static 关键字修饰变量时，我们称此变量为静态变量。

静态变量的存储方式与全局变量一样，都是静态存储方式。但这里需要特别说明的是，静态变量属于静态存储方式，属于静态存储方式的变量却不一定就是静态变量。例如，全局变量虽然属于静态存储方式，但并不是静态变量，它必须由 static 加以定义后才能成为静态全局变量。

#### 隐藏与隔离的作用

上面已经阐述过，全局变量虽然属于静态存储方式，但并不是静态变量。全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的。

如果我们希望全局变量仅限于在本源文件中使用，在其他源文件中不能引用，也就是说限制其作用域只在定义该变量的源文件内有效，而在同一源程序的其他源文件中不能使用。这时，就可以通过在全局变量之前加上关键字 static 来实现，使全局变量被定义成为一个静态全局变量。这样就可以避免在其他源文件中引起的错误。也就起到了对其他源文件进行隐藏与隔离错误的作用，有利于模块化程序设计。

#### 保持变量内容的持久性

有时候，我们希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 static 声明为“静态局部变量”。

当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的栈中存放改为静态存储区存放。这让它看起来很像全局变量，其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中是可见的。

对某些必须在调用之间保持局部变量的值的子程序而言，静态局部变量是特别重要的。如果没有静态局部变量，则必须在这类函数中使用全局变量，由此也就打开了引入副作用的大门。使用静态局部变量最好的示例就是实现统计次数的功能，如下面示例所示。

```cpp
#include <stdio.h>
void count();
int main(void)
{
    int i=0;
    for (i = 0;i <= 5;i++)
    {
            count();
    }
    return 0;
}
void count()
{
    /*声明一个静态局部变量*/
    static num = 0;
    num++;
    printf("%d\n",num);
}
```

在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就不再重新赋初值，而是保留上次函数调用结束时的值。这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。

通过上面的示例，我们可以得出静态局部变量一般的使用场景，如下所示：

- 需要保留函数上一次调用结束时的值。
- 如果初始化后，变量只会被引用而不会改变其值，则这时用静态局部变量比较方便，以免每次调用时重新赋值。

#### 默认初始化为0

在静态数据区，内存中所有的字节默认值都是 0x00。静态变量与全局变量也一样，它们都存储在静态数据区中，因此其变量的值默认也为 0。演示示例如下所示。



```cpp
#include <stdio.h>
static int g_x;
int g_y;
int main(void)
{
    static int x;
    printf("g_x：%d\ng_y：%d\nx：%d",g_x,g_y,x);
    return 0;
}
```



## 内联函数

一般来说，调用一个函数流程为：当前调用命令的地址被保存下来，程序流跳转到所调用的函数并执行该函数，最后跳转回之前所保存的命令地址。

对于需要经常调用的小函数来说，这大大降低了程序运行效率。所以，C99 新增了内联函数（inline function）。

关键字 inline 告诉编译器，任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方。这样程序执行更有效率，就好像将内联函数中的语句直接插入到了源代码文件中需要调用该函数的地方一样。

```cpp
// 函数swapf()交换两个浮点变量的值
// 参数：两个指向float的指针
// 返回值：无
inline void swapf( float *p1, float *p2 )       // 一个内联函数
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}
// 函数selection_sortf() 使用 selection-sort算法
// 对float数组进行排序
// 参数：一个float数组，以及其长度
// 返回值：无
void selection_sortf( float a[], int n )        // 对长度为n的数组进行排序
{
  register int i, j, mini;                      // 3个索引变量
  for ( i = 0; i < n - 1; ++i )
  {
    mini = i;                                   // 从索引i开始，寻找最小值
    for ( j = i+1; j < n; ++j )
      if ( a[j] < a[mini] )
        mini = j;
      swapf( a+i, a+mini);                      // 交换最小值元素和索引i元素的值
  }
}
```

一般来说，不建议把将包含循环的函数定义成内联函数，例如函数 selection_sortf（）。例 1 在 for 循环中使用内联函数来加速执行效率。

inline 修饰符并非强制性的：编译器有可能会置之不理。例如，递归函数通常不会被编译成内联函数。编译器有权自行决定是否要将有 inline 修饰符的函数编译成内联函数。

和其他函数不同的是，在每个用到内联函数的翻译单元中，都必须重复定义这个内联函数。编译器必须时刻准备好该函数定义，以便在调用它时及时插入内联代码。因此，经常在头文件中定义内联函数。

如果某个翻译单元内的某个函数的所有声明都具有 inline 修饰符，而没有 extern 修饰符，那么该函数具有内联定义（inline definition）。

内联定义只针对翻译单元，它不构成外部定义，因此别的翻译单元可以包含该函数的外部定义。如果有外部定义附加到内联定义中，那么编译器可以自由选择要使用哪一种定义。

如果使用存储类修饰符 extern 来声明一个采用 inline 定义的函数，那么该函数的定义就会是外部的（external）。例如，下面的声明与 swapf（）的定义如果放在例 1 的同一个翻译单元中，那么 swapf（）就具有 extern 定义：

```cpp
extern void swapf( float *p1, float *p2 );
```

一旦函数 swapf（）具有外部的定义，其他翻译单元只需要采用普通的函数声明，就可以调用它。然而，从别的翻译单元调用函数，将不会被编译成内联函数。

内联函数其实就是普通函数，只不过它们在调用时采用机器码形式。和普通函数一样，内联函数具有自己的地址。如果内联函数使用到宏，预处理器就会展开宏，展开时所用的宏值，取该内联函数在源代码中定义所在位置的宏值。然而，在没被声明为 static 的内联函数中，不应该以静态存储周期的方式来定义可修改的对象。

## volatile

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：

```cpp
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。注意，在 VC 6 中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响，输入下面的代码：

## constexpr

constexpr 是 C++ 11 标准新引入的关键字，不过在讲解其具体用法和功能之前，读者需要先搞清楚 C++ 常量表达式的含义。

所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。

实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：

```cpp
// 1)
int url[10];//正确
// 2)
int url[6 + 4];//正确
// 3)
int length = 6;
int url[length];//错误，length是变量
```

上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。

我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。

constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。

**注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。**



### constexpr修饰普通变量

C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。

值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：

```cpp
#include <iostream>
using namespace std;
int main()
{
    constexpr int num = 1 + 2 + 3;
    int url[num] = {1,2,3,4,5,6};
    couts<< url[1] << endl;
    return 0;
}

//2
```

可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 "1+2+3" 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。

有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。

**注意：const和constexpr并不相同**

另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。

### constexpr修饰函数

